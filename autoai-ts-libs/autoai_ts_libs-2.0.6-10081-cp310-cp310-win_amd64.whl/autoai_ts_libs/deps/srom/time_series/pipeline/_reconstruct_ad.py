import inspect
import logging

import numpy as np
import pandas as pd
from sklearn.pipeline import Pipeline
from autoai_ts_libs.deps.srom.preprocessing.ts_transformer import TimeTensorTransformer
from autoai_ts_libs.deps.srom.time_series.utils.anomaly import (
    contextual_score,
    chi_square_score,
    q_score,
    adaptive_window_score,
    window_score,
)
from autoai_ts_libs.deps.srom.utils.estimator_utils import check_model_type_is_dl

LOGGER = logging.getLogger(__name__)


class ReconstructAD(Pipeline):
    """
    This class develop encoder-decoder detection method to time
    series by applying windowing techniques. The anomaly score is generated by the reconstruction error \
    generated while a data point is being reconstructed

    Parameters
    ----------
        steps : list of pipeline steps
            List of ReconstructAD pipelines to be used.
        feature_columns : list, optional
            List of feature columns to be used
        target_columns : list, optional
            List of target columns to be used
        lookback_win : int, optional
            Lookback window used for prediction
        time_column : string/int, optional
            Column name of time column
        pred_win : int, optional
            Prediction window used for transformations
        store_lookback_history : boolean, optional
            Boolean value to decide if lookback window history should be stored. To be set to true if test data \
            is continuous from the train data
        distance_metric : string, optional
            unused : TODO
        observation_window : int, optional
            Observation window is used to compute anomaly scores by specified scoring_method. Defaults to 10.
        scoring_method : string, optional
            Anomaly scoring method to compute anomaly score in specified mathematical,
            or statistical method. The computed score is used to label anomalies by
            analyzing residuals computed. Defaults to Chi-Square.
        scoring_threshold : int, optional
            Scoring threhold is used to label computed anomaly score as anomaly or normal. Defaults to 10.
    """

    def __init__(
        self,
        steps,
        *,
        feature_columns=None,
        target_columns=None,
        lookback_win=None,
        time_column=None,
        pred_win=0,
        store_lookback_history=True,
        distance_metric=None,
        observation_window=10,
        scoring_method="iid",
        scoring_threshold=10,
        scoring_noise_adjustment=None,
        reverse_windowing=False,
    ):
        self.feature_columns = feature_columns
        self.target_columns = target_columns
        self.lookback_win = lookback_win
        self.time_column = time_column
        self.pred_win = pred_win
        self.store_lookback_history = store_lookback_history
        self.distance_metric = distance_metric
        self.observation_window = observation_window
        self.scoring_method = scoring_method
        self.scoring_threshold = scoring_threshold
        self.steps = steps
        self.scoring_noise_adjustment=scoring_noise_adjustment
        self.reverse_windowing = reverse_windowing
        super(ReconstructAD, self).__init__(steps=steps)

    def _forward_fit_data_transformation(self, X, y=None):
        """
        Internal function to get the time series data
        """
        Xt = X.copy()
        yt = y
        for _, transformer in self.steps[:-1]:
            if hasattr(transformer, "fit_transform"):
                res = transformer.fit_transform(Xt, yt)
            else:
                res = transformer.fit(Xt, yt).transform(Xt)

            if isinstance(res, tuple):
                x_res = res[0]
                yt = res[1]
            else:
                x_res = res

            Xt = x_res

        return Xt

    def set_anomaly_scoring_params(self, scoring_method, scoring_threshold):
        """
        This is a scoring threshold
        """
        self.scoring_method = scoring_method
        self.scoring_threshold = scoring_threshold

    def _forward_data_transformation(self, X, is_lookback_appended, lookback_win):
        """
        Internal function to get the time series data
        """
        # now call the anomaly score generation, which generate the anomaly score
        # Xt = X.copy()
        # for _, _, transform in self._iter(with_final=False):
        #     res = transform.transform(Xt)
        #     if isinstance(res, tuple):
        #         x_res = res[0]
        #         yt = res[1]
        #     else:
        #         x_res = res
        #     Xt = x_res
        # return Xt
        Xt = X.copy()
        for _, transformer in self.steps[:-1]:
            params = {}

            if "is_lookback_appended" in inspect.signature(transformer.transform).parameters:
                params["is_lookback_appended"] = is_lookback_appended
            if "lookback_win" in inspect.signature(transformer.transform).parameters:
                params["lookback_win"] = lookback_win

            if len(params) > 0:
                res = transformer.transform(Xt, **params)
            else:
                res = transformer.transform(Xt)

            if isinstance(res, tuple):
                x_res = res[0]
            else:
                x_res = res

            Xt = x_res

        return Xt

    def _set_steps_for_fit(self):
        """
        Must be called from fit only
        """
        step_params = [
            "lookback_win",
            "target_columns",
            "feature_columns",
            "time_column",
            "distance_metric",
        ]

        for step in self.steps:
            params = {}
            for param in step_params:
                if param in step[1].get_params().keys():
                    params[param] = getattr(self, param)
            if len(params) != 0:
                step[1].set_params(**params)

        # dealing with Flatten and pred_win
        for step in self.steps:
            if (
                isinstance(step[1], TimeTensorTransformer)
                and "pred_win" in step[1].get_params().keys()
            ):
                step[1].set_params(pred_win=0)

    def fit(self, X, y=None, val_data=None):
        """
        This method create an srom estimator object and then call its fit

        Important steps:
        feature_columns attribute need to pass to the respecting object of steps

        for each step in self.steps:
            get its parameter
            set some of its parameter such as feature_columns, target_columns
            this one need little bit co-ordination across different method such as
            flatten etc
        """

        self._set_steps_for_fit()
        if self.store_lookback_history:
            self._store_lookback_history_X(X)
        Xt = X.copy()

        Xt = self._forward_fit_data_transformation(Xt)

        # adjust the output dimension and input dimension
        if hasattr(self.steps[-1][1], "set_params") and callable(
            getattr(self.steps[-1][1], "set_params")
        ):
            # update input and output dimension of the Deep learning models
            if "input_dimension" in self.steps[-1][
                1
            ].get_params() and check_model_type_is_dl(self.steps[-1][1]):

                if Xt.ndim == 2:
                    in_dim = Xt.shape[1]
                elif Xt.ndim == 3:
                    in_dim = (Xt.shape[1], Xt.shape[2])

                self.steps[-1][1].set_params(input_dimension=in_dim)
        
        val_Xt = None
        if val_data is not None:
            val_Xt = val_data.copy()
            val_Xt = self._forward_data_transformation(val_Xt, is_lookback_appended=False, lookback_win=0)

        if check_model_type_is_dl(self.steps[-1][1]):
            self.steps[-1][1].fit(Xt, Xt, val_data=val_Xt)
        else:
            self.steps[-1][1].fit(Xt)      
        
        # now we pass the X to trained pipeline and generate the training
        # anomaly score
        # training_error = len(X)
        sampleXt = self.steps[-1][1].predict(Xt)

        anomaly_score = []
        if Xt.ndim == 2:
            diff_x = Xt - sampleXt
            anomaly_score = np.nanmean(diff_x, axis=1)
            anomaly_score = np.array(anomaly_score).reshape(-1, 1)
        elif Xt.ndim == 3:
            if Xt.shape[2] == 1 and sampleXt.shape != Xt.shape:
                sampleXt = sampleXt.reshape(sampleXt.shape[0], sampleXt.shape[1], 1)
            diff_x = Xt - sampleXt
            anomaly_score = np.nanmean(diff_x, axis=1)
            anomaly_score = np.nanmean(anomaly_score, axis=1)
            anomaly_score = np.array(anomaly_score).reshape(-1, 1)

        if len(anomaly_score) != len(X):
            dummy = np.full(
                (X.shape[0] - anomaly_score.shape[0], anomaly_score.shape[1],), np.NaN,
            )
            self.training_error_ = np.concatenate((dummy, anomaly_score))
        else:
            self.training_error_ = anomaly_score
        return self

    def _store_lookback_history_X(self, X):
        """Utility function : it must be called from fit() or its method called out of fit()

        Args:
            X ([type]): [description]

        Raises:
            Exception: [description]
        """
        if self.store_lookback_history:
            if self.lookback_win > 0:
                self.lookback_data_X_ = X[-self.lookback_win:, :]
            else:
                self.lookback_data_X_ = None
        else:
            raise Exception("Lookback information is not stored inside model")

    def _add_lookback_history_to_X(self, X):
        """Predict or Anomaly Score

        Args:
            X ([np.array]): data

        Raises:
            Exception: Lookback information is not stored inside model

        Returns:
            [np.array]: X after lookback history is added
        """
        if self.store_lookback_history:
            if X is None:
                if self.lookback_win > 0:
                    return self.lookback_data_X_.copy()
                else:
                    return X
            else:
                if self.lookback_win > 0:
                    new_X = np.concatenate([self.lookback_data_X_, X])
                    return new_X
                else:
                    return X
        else:
            raise Exception("Lookback information is not stored inside model")

    def _predict_batch(self, X, prediction_type="batch"):
        if prediction_type not in ["batch", "training"]:
            return None
        if X is not None:
            if self.scoring_method == "iid":  # Point Anomaly

                is_lookback_appended = False
                lookback_win = 0
                if self.store_lookback_history:
                    # we add the lookback window
                    old_X_shape = X.shape
                    X = self._add_lookback_history_to_X(X)
                    is_lookback_appended = True
                    lookback_win = X.shape[0] - old_X_shape[0]
                X = self._forward_data_transformation(
                    X, is_lookback_appended, lookback_win
                )
                predictions = self.steps[-1][1].predict(X)
                start_index = 0
                anomaly_score = []
                if X.ndim == 2:
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)
                elif X.ndim == 3:
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.nanmean(anomaly_score, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)

                threshold_ = self.scoring_threshold
                if len(anomaly_score.shape) > 1:
                    anomaly_score = anomaly_score.reshape(-1)
                    if (
                        type(self.scoring_threshold) != int
                        and len(self.scoring_threshold.shape) > 1
                    ):
                        threshold_ = self.scoring_threshold.reshape(-1)
                anomaly_score[anomaly_score > threshold_] = -1
                anomaly_score[anomaly_score != -1] = 1
                predictions = anomaly_score.copy()
                return predictions[start_index:]
            else:
                # here we call decision_function and then
                if self.scoring_method == "Contextual-Anomaly":
                    """
                    this place anomaly_score return the
                    We shd align the output with other methods like
                    1 and -1
                    """
                    score_ = self.anomaly_score(
                        X, return_threshold=False, prediction_type=prediction_type
                    )
                    score_[score_ > 0] = -1
                    score_[score_ != -1] = 1
                    return score_

                else:
                    """
                    we need to generate the label
                    """
                    score_, threshold_ = self.anomaly_score(
                        X, return_threshold=True, prediction_type=prediction_type
                    )
                    if len(score_.shape) > 1:
                        score_ = score_.reshape(-1)
                        if type(threshold_) != int and len(threshold_.shape) > 1:
                            threshold_ = threshold_.reshape(-1)
                    score_[score_ > threshold_] = -1
                    score_[score_ != -1] = 1
                    return score_
        else:
            return self._predict_empty_test(
                X, prediction_type=prediction_type, start_index=0
            )

    def _predict_sliding(self, X, prediction_type="sliding"):
        if X is not None:
            if self.scoring_method == "iid":  # Point Anomaly

                is_lookback_appended = False
                lookback_win = 0

                if self.store_lookback_history:
                    # we add the lookback window
                    old_X_shape = X.shape
                    X = self._add_lookback_history_to_X(X)
                    is_lookback_appended = True
                    lookback_win = X.shape[0] - old_X_shape[0]

                X = self._forward_data_transformation(
                    X, is_lookback_appended, lookback_win
                )
                predictions = self.steps[-1][1].predict(X)
                anomaly_score = []
                if X.ndim == 2:
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)
                elif X.ndim == 3:
                    if X.shape != predictions.shape:
                        if X.shape[2] == 1 and predictions.ndim == 2:
                            predictions = predictions.reshape(
                                X.shape[0], X.shape[1], X.shape[2]
                            )
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.nanmean(anomaly_score, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)

                threshold_ = self.scoring_threshold
                if len(anomaly_score.shape) > 1:
                    anomaly_score = anomaly_score.reshape(-1)
                    if (
                        type(self.scoring_threshold) != int
                        and len(self.scoring_threshold.shape) > 1
                    ):
                        threshold_ = self.scoring_threshold.reshape(-1)
                anomaly_score[anomaly_score > threshold_] = -1
                anomaly_score[anomaly_score != -1] = 1
                start_index = -X.shape[0]
                predictions = anomaly_score.copy()
                return predictions[start_index:]
            else:
                # here we call decision_function and then
                """
                we need to generate the label
                """
                score_, threshold_ = self.anomaly_score(
                    X, return_threshold=True, prediction_type=prediction_type
                )
                if self.scoring_method == "Contextual-Anomaly":
                    threshold_ = 0
                if len(score_.shape) > 1:
                    score_ = score_.reshape(-1)
                    if type(threshold_) != int and len(threshold_.shape) > 1:
                        threshold_ = threshold_.reshape(-1)
                score_[score_ > threshold_] = -1
                score_[score_ != -1] = 1
                start_index = -X.shape[0]
                return score_[start_index:]
        else:
            return self._predict_empty_test(
                X, prediction_type=prediction_type, start_index=-X.shape[0]
            )

    def _predict_recent(self, X, prediction_type="recent"):
        if X is not None:
            if self.scoring_method == "iid":  # Point Anomaly

                is_lookback_appended = False
                lookback_win = 0

                if self.store_lookback_history:
                    # we add the lookback window
                    old_X_shape = X.shape
                    X = self._add_lookback_history_to_X(X)
                    is_lookback_appended = True
                    lookback_win = X.shape[0] - old_X_shape[0]

                X = self._forward_data_transformation(
                    X, is_lookback_appended, lookback_win
                )
                predictions = self.steps[-1][1].predict(X)
                anomaly_score = []
                if X.ndim == 2:
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)
                elif X.ndim == 3:
                    if X.shape != predictions.shape:
                        if X.shape[2] == 1 and predictions.ndim == 2:
                            predictions = predictions.reshape(
                                X.shape[0], X.shape[1], X.shape[2]
                            )
                    diff_x = X - predictions
                    anomaly_score = np.nanmean(diff_x, axis=1)
                    anomaly_score = np.nanmean(anomaly_score, axis=1)
                    anomaly_score = np.array(anomaly_score).reshape(-1, 1)

                threshold_ = self.scoring_threshold
                if len(anomaly_score.shape) > 1:
                    anomaly_score = anomaly_score.reshape(-1)
                    if type(threshold_) != int and len(threshold_.shape) > 1:
                        threshold_ = self.scoring_threshold.reshape(-1)
                anomaly_score[anomaly_score > threshold_] = -1
                anomaly_score[anomaly_score != -1] = 1
                start_index = -1
                predictions = anomaly_score.copy()
                return predictions[start_index:]
            else:
                # here we call decision_function and then
                """
                    we need to generate the label
                    """
                score_, threshold_ = self.anomaly_score(
                    X, return_threshold=True, prediction_type=prediction_type
                )
                if self.scoring_method == "Contextual-Anomaly":
                    threshold_ = 0
                score_[score_ > threshold_] = -1
                score_[score_ != -1] = 1
                return score_
        else:
            return self._predict_empty_test(
                X, prediction_type=prediction_type, start_index=-1
            )

    def _predict_empty_test(self, X, prediction_type, start_index):
        if self.scoring_method == "Contextual-Anomaly":
            """
            this place anomaly_score return the
            We shd align the output with other methods like
            1 and -1
            """
            score_ = self.training_error_.copy()
            score_[score_ > 0] = -1
            score_[score_ != -1] = 1
            return score_
        else:
            score_ = self.training_error_.copy()
            if self.scoring_method == "iid":
                return score_[start_index:]
            else:
                score_, threshold_ = self.anomaly_score(
                    X=X, return_threshold=True, prediction_type=prediction_type
                )
                if len(score_.shape) > 1:
                    score_ = score_.reshape(-1)
                    if len(threshold_.shape) > 1:
                        threshold_ = threshold_.reshape(-1)
                score_[score_ > threshold_] = -1
                score_[score_ != -1] = 1
                return score_

    def predict(self, X, prediction_type="recent"):
        if prediction_type == "recent":
            score = self._predict_recent(X, prediction_type=prediction_type)
        if prediction_type == "sliding":
            score = self._predict_sliding(X, prediction_type=prediction_type)
        if prediction_type == "batch":
            score = self._predict_batch(X, prediction_type=prediction_type)
        return score

    def anomaly_score(self, X, return_threshold=False, prediction_type="recent"):
        """
        anomaly score
            batch and training does not append the data
            rest append the lookback window data to given X (this is in sync with )
        """
        # X exists case
        # add the lookback window
        if X is not None:
            Xt = X.copy()
            is_lookback_appended = False
            lookback_win = 0
            if self.store_lookback_history:
                if prediction_type not in ["training", "batch"]:
                    # we add the lookback window
                    old_X_shape = X.shape
                    Xt = self._add_lookback_history_to_X(X.copy())
                    is_lookback_appended = True
                    lookback_win = Xt.shape[0] - old_X_shape[0]

            Xt = self._forward_data_transformation(
                Xt, is_lookback_appended=is_lookback_appended, lookback_win=lookback_win
            )
            sampleXt = self.steps[-1][1].predict(Xt)
            if Xt.ndim == 2:
                diff_x = Xt - sampleXt
                anomaly_score = np.nanmean(diff_x, axis=1)
                anomaly_score = np.array(anomaly_score).reshape(-1, 1)
            elif Xt.ndim == 3:
                if Xt.shape[2] == 1 and sampleXt.shape != Xt.shape:
                    sampleXt = sampleXt.reshape(Xt.shape[0], Xt.shape[1], 1)
                diff_x = Xt - sampleXt
                anomaly_score = np.nanmean(diff_x, axis=1)
                anomaly_score = np.nanmean(anomaly_score, axis=1)
                anomaly_score = np.array(anomaly_score).reshape(-1, 1)
            else:
                raise Exception("Reshape input data")
        else:
            anomaly_score = self.training_error_.copy()

        # now we have anomaly score, these score we can tread as iid (if scoring method is iid)
        # else we post process as follow
        if self.scoring_method not in ["iid", "Contextual-Anomaly"]:
            if prediction_type not in ["batch", "training"]:
                if anomaly_score is not None:
                    anomaly_score = np.concatenate(
                        (self.training_error_, np.array(anomaly_score).reshape(-1, 1),)
                    )
                else:
                    anomaly_score = self.training_error_.copy()
            anomaly_score = self._post_process_anomaly(anomaly_score, return_threshold)
        elif self.scoring_method == "Contextual-Anomaly":
            # post processing is required here
            # we shd send the anomaly_score as similar as other anomaly score
            # it will be 0 for no anomaly and anomaly_severity for the other cases
            # if we fix this, then its very easy for us to align all the code in predict
            score = self._post_process_anomaly(anomaly_score, return_threshold)
            score = pd.DataFrame(score)
            if X is not None:
                output = pd.DataFrame(
                    0, index=range(len(X)), columns=["Score"], dtype="float"
                )
            else:
                output = pd.DataFrame(
                    0, index=range(len(anomaly_score)), columns=["Score"], dtype="float"
                )
            for row in score.itertuples(index=False):
                output.loc[row[0] : row[1], "Score"] = row[2]
            anomaly_score = output["Score"].values

        # What score to be returned
        start_index = 0
        if prediction_type == "recent":
            start_index = -1
        elif prediction_type == "sliding":
            start_index = -X.shape[0]
        else:
            pass
        if return_threshold:
            if self.scoring_method == "iid":
                return (anomaly_score[start_index:], anomaly_score[start_index:])
            elif self.scoring_method == "Contextual-Anomaly":
                return (anomaly_score[start_index:], np.zeros(anomaly_score.shape))
            else:
                return (
                    anomaly_score[0][start_index:,],
                    anomaly_score[1][start_index:,],
                )
        return anomaly_score[start_index:]

    def _post_process_anomaly(self, anomaly_score, return_threshold):
        if return_threshold:
            if self.scoring_method == "Chi-Square":
                return chi_square_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )
            elif self.scoring_method == "Q-Score":
                return q_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )
            elif self.scoring_method == "Sliding-Window":
                return window_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )
            elif self.scoring_method == "Adaptive-Sliding-Window":
                return adaptive_window_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )
            elif self.scoring_method == "Contextual-Anomaly":
                return contextual_score(
                    anomaly_score,
                    scoring_threshold=self.scoring_threshold,
                    observation_window=self.observation_window,
                )
            else:
                raise Exception("Wrong option for scoring method")
        else:
            if self.scoring_method == "Chi-Square":
                return chi_square_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )[0]
            elif self.scoring_method == "Q-Score":
                return q_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )[0]
            elif self.scoring_method == "Sliding-Window":
                return window_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )[0]
            elif self.scoring_method == "Adaptive-Sliding-Window":
                return adaptive_window_score(
                    anomaly_score, self.observation_window, self.scoring_threshold
                )[0]
            elif self.scoring_method == "Contextual-Anomaly":
                return contextual_score(
                    anomaly_score,
                    scoring_threshold=self.scoring_threshold,
                    observation_window=self.observation_window,
                )
            else:
                raise Exception("Wrong option for scoring method")
